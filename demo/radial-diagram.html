<!DOCTYPE html>
<!--
  Radial Diagram Generator - Single File Version

  AUTO-GENERATED FILE - Do not edit directly!
  Run: npm run build:standalone

  @license MIT
  @copyright 2026 CGA Management Ltd
  @see https://www.cgamanagement.co.uk/category/tools
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Radial Diagram Generator</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
      color: #333;
    }
    h1 { margin: 0 0 20px; font-size: 24px; }
    .container {
      display: flex;
      gap: 20px;
      max-width: 1400px;
      margin: 0 auto;
    }
    .editor-panel, .preview-panel {
      flex: 1;
      min-width: 400px;
    }
    textarea {
      width: 100%;
      height: 600px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 12px;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: vertical;
    }
    .preview-container {
      background: white;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 20px;
      text-align: center;
      transition: background-color 0.3s;
    }
    .preview-container.dark { border-color: #444; }
    .preview-container svg { max-width: 100%; height: auto; }
    .buttons {
      margin: 10px 0;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    button {
      padding: 8px 16px;
      font-size: 14px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #4a90d9;
      color: white;
    }
    button:hover { background: #357abd; }
    button.secondary { background: #666; }
    button.secondary:hover { background: #555; }
    .error { color: #c00; font-size: 12px; margin-top: 8px; }
    .help { font-size: 12px; color: #666; margin-top: 8px; }
    footer {
      max-width: 1400px;
      margin: 40px auto 20px;
      padding-top: 20px;
      border-top: 1px solid #ddd;
      text-align: center;
      font-size: 13px;
      color: #666;
    }
    footer a { color: #4a90d9; text-decoration: none; }
    footer a:hover { text-decoration: underline; }
    @media (max-width: 900px) {
      .container { flex-direction: column; }
      .editor-panel, .preview-panel { min-width: 100%; }
    }
  </style>
</head>
<body>
  <h1>Radial Diagram Generator</h1>

  <div class="container">
    <div class="editor-panel">
      <h3>Configuration (JSON)</h3>
      <textarea id="config-editor" spellcheck="false"></textarea>
      <div class="buttons">
        <button onclick="renderDiagram()">Render</button>
        <button class="secondary" onclick="downloadSVG()">Download SVG</button>
        <button class="secondary" onclick="downloadPNG()">Download PNG</button>
      </div>
      <div id="error" class="error"></div>
      <div class="help">
        Edit the JSON configuration - click Render to update.
        Scores range from 1-5 (or as defined in scale). Set score to null to hide fill.
      </div>
    </div>

    <div class="preview-panel">
      <h3>Preview</h3>
      <div class="preview-container" id="preview">
        <p style="color: #999;">Click "Render" to generate diagram</p>
      </div>
    </div>
  </div>

  <footer>
    Built by <a href="https://cgamanagement.co.uk/category/tools/" target="_blank" rel="noopener">CGA Management Ltd</a>.
    <a href="https://github.com/andycop/radial-diagram" target="_blank" rel="noopener">GitHub</a> |
    Licensed under MIT.
  </footer>

  <script>
    // ============================================================
    // Geometry Utilities (from src/core/geometry.ts)
    // ============================================================

    function polarToCartesian(cx, cy, radius, angleDegrees) {
      const angleRadians = (angleDegrees * Math.PI) / 180;
      return {
        x: cx + radius * Math.cos(angleRadians),
        y: cy + radius * Math.sin(angleRadians)
      };
    }

    function segmentPath(cx, cy, innerRadius, outerRadius, startAngle, endAngle) {
      const outerStart = polarToCartesian(cx, cy, outerRadius, startAngle);
      const outerEnd = polarToCartesian(cx, cy, outerRadius, endAngle);
      const innerStart = polarToCartesian(cx, cy, innerRadius, startAngle);
      const innerEnd = polarToCartesian(cx, cy, innerRadius, endAngle);
      const angleDiff = endAngle - startAngle;
      const largeArcFlag = Math.abs(angleDiff) > 180 ? 1 : 0;

      if (innerRadius === 0) {
        return [
          `M ${cx} ${cy}`,
          `L ${outerStart.x} ${outerStart.y}`,
          `A ${outerRadius} ${outerRadius} 0 ${largeArcFlag} 1 ${outerEnd.x} ${outerEnd.y}`,
          'Z'
        ].join(' ');
      }

      return [
        `M ${outerStart.x} ${outerStart.y}`,
        `A ${outerRadius} ${outerRadius} 0 ${largeArcFlag} 1 ${outerEnd.x} ${outerEnd.y}`,
        `L ${innerEnd.x} ${innerEnd.y}`,
        `A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${innerStart.x} ${innerStart.y}`,
        'Z'
      ].join(' ');
    }

    function segmentAngle(segmentCount) {
      if (segmentCount <= 0) throw new Error('segmentCount must be greater than 0');
      return 360 / segmentCount;
    }

    function facetAngles(segmentStartAngle, segmentEndAngle, facetCount) {
      if (facetCount <= 0) throw new Error('facetCount must be greater than 0');
      const totalAngle = segmentEndAngle - segmentStartAngle;
      const facetAngleSpan = totalAngle / facetCount;
      return Array.from({ length: facetCount }, (_, i) => {
        const startAngle = segmentStartAngle + i * facetAngleSpan;
        const endAngle = startAngle + facetAngleSpan;
        const midAngle = (startAngle + endAngle) / 2;
        return { startAngle, endAngle, midAngle };
      });
    }

    function scoreToRadius(score, minScore, maxScore, innerRadius, outerRadius) {
      if (minScore > maxScore) throw new Error('minScore must be <= maxScore');
      if (innerRadius >= outerRadius) throw new Error('innerRadius must be < outerRadius');
      if (minScore === maxScore) return outerRadius;
      const clampedScore = Math.max(minScore, Math.min(maxScore, score));
      const levels = maxScore - minScore + 1;
      const radiusRange = outerRadius - innerRadius;
      const normalizedScore = (clampedScore - minScore + 1) / levels;
      return innerRadius + normalizedScore * radiusRange;
    }

    function ringRadii(ringCount, innerRadius, outerRadius) {
      if (ringCount <= 0) throw new Error('ringCount must be greater than 0');
      if (innerRadius >= outerRadius) throw new Error('innerRadius must be < outerRadius');
      const step = (outerRadius - innerRadius) / ringCount;
      return Array.from({ length: ringCount + 1 }, (_, i) => innerRadius + i * step);
    }

    // ============================================================
    // Types and Config (from src/core/types.ts)
    // ============================================================

    const DEFAULT_STYLE = {
      showRings: true,
      ringColor: '#cccccc',
      ringWidth: 1,
      ringStyle: 'dashed',
      showScoreLabels: false,
      scoreLabelFontSize: 14,
      scoreLabelColor: '#ffffff',
      scoreLabelStrokeColor: '#333333',
      showFacetPoints: true,
      facetPointStyle: 'circle',
      facetOpacity: 1,
      segmentDividerWidth: 2,
      fontFamily: 'Arial, sans-serif',
      segmentDividerColor: '#ffffff',
      showSegmentDividers: true,
      hubFontSize: 14,
      hubFontColor: '#ffffff',
      segmentFontSize: 28,
      facetFontSize: 11
    };

    const DEFAULT_SCALE = { min: 1, max: 5, rings: 5 };

    function createConfig(partial) {
      return {
        center: {
          label: partial.center?.label ?? 'Core',
          radius: partial.center?.radius ?? 60,
          color: partial.center?.color ?? '#8B3A62',
          subtitle: partial.center?.subtitle,
          borderWidth: partial.center?.borderWidth,
          borderColor: partial.center?.borderColor,
          visible: partial.center?.visible,
          fontSize: partial.center?.fontSize,
          fontColor: partial.center?.fontColor
        },
        scale: { ...DEFAULT_SCALE, ...partial.scale },
        segments: partial.segments || [],
        style: { ...DEFAULT_STYLE, ...partial.style },
        size: partial.size || 800,
        startAngle: partial.startAngle ?? -90
      };
    }

    function validateConfig(config) {
      const errors = [];
      if (!config.size || config.size <= 0) errors.push('size must be > 0');
      if (!config.center) errors.push('center configuration is required');
      else if (!config.center.radius || config.center.radius <= 0) errors.push('center.radius must be > 0');
      if (!config.scale) errors.push('scale configuration is required');
      else {
        if (config.scale.min > config.scale.max) errors.push('scale.min must be <= scale.max');
        if (!config.scale.rings || config.scale.rings <= 0) errors.push('scale.rings must be > 0');
      }
      if (!config.segments || config.segments.length === 0) errors.push('segments array must have at least one segment');
      else {
        config.segments.forEach((seg, i) => {
          if (!seg.facets || seg.facets.length === 0) errors.push(`segment[${i}] must have at least one facet`);
        });
      }
      if (config.size && config.center?.radius) {
        const outerRadius = (config.size / 2) * 0.9;
        if (config.center.radius >= outerRadius) {
          errors.push(`center.radius (${config.center.radius}) must be < outer radius (${outerRadius.toFixed(1)})`);
        }
      }
      return { valid: errors.length === 0, errors };
    }

    // ============================================================
    // SVG Renderer (from src/renderers/svg.ts)
    // ============================================================

    class SVGRenderer {
      constructor(config) {
        const validation = validateConfig(config);
        if (!validation.valid) throw new Error('Invalid config:\n- ' + validation.errors.join('\n- '));
        this.config = config;
        this.cx = config.size / 2;
        this.cy = config.size / 2;
        this.outerRadius = (config.size / 2) * 0.9;
        this.padding = 70;
      }

      render() {
        const elements = [];
        if (this.config.style.backgroundColor) elements.push(this.renderBackground());
        elements.push(this.renderSegmentBackgrounds());
        elements.push(this.renderScoreFills());
        if (this.config.style.showSegmentDividers) elements.push(this.renderSegmentDividers());
        elements.push(this.renderFacetDividers());
        elements.push(this.renderCenterHub());
        elements.push(this.renderFacetLabels());
        elements.push(this.renderSegmentLabels());
        if (this.config.style.showRings !== false) elements.push(this.renderRings());
        if (this.config.style.showScoreLabels) elements.push(this.renderScoreLabels());
        return this.wrapSVG(elements.join('\n'));
      }

      wrapSVG(content) {
        const { size, style, center } = this.config;
        const viewSize = size + this.padding * 2;
        const hubFontSize = center.fontSize || style.hubFontSize || 14;
        const hubFontColor = center.fontColor || style.hubFontColor || '#ffffff';
        const segmentFontSize = style.segmentFontSize || 28;
        const facetFontSize = style.facetFontSize || 11;
        const facetFontColor = style.facetFontColor || '#000000';
        return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${-this.padding} ${-this.padding} ${viewSize} ${viewSize}" width="${size}" height="${size}">
  <style>
    .segment-label { font-family: ${style.fontFamily}; font-weight: bold; font-size: ${segmentFontSize}px; fill: white; dominant-baseline: middle; }
    .facet-label { font-family: ${style.fontFamily}; font-size: ${facetFontSize}px; font-style: italic; fill: ${facetFontColor}; }
    .center-label { font-family: ${style.fontFamily}; font-weight: bold; font-size: ${hubFontSize}px; fill: ${hubFontColor}; text-anchor: middle; }
    .ring-label { font-family: ${style.fontFamily}; font-size: 10px; fill: #666; }
  </style>
  ${content}
</svg>`;
      }

      renderBackground() {
        const viewSize = this.config.size + this.padding * 2;
        return `<rect x="${-this.padding}" y="${-this.padding}" width="${viewSize}" height="${viewSize}" fill="${this.config.style.backgroundColor}" />`;
      }

      renderRings() {
        const { scale, center, style } = this.config;
        const rings = ringRadii(scale.rings, center.radius, this.outerRadius);
        const elements = [];
        const ringColor = style.ringColor || '#cccccc';
        const ringWidth = style.ringWidth || 1;
        const dashArray = (style.ringStyle || 'dashed') === 'dashed' ? 'stroke-dasharray="4,4"' : '';
        rings.forEach((radius, i) => {
          if (i === 0) return;
          elements.push(`<circle cx="${this.cx}" cy="${this.cy}" r="${radius}" fill="none" stroke="${ringColor}" stroke-width="${ringWidth}" ${dashArray} />`);
        });
        return `<g class="rings">${elements.join('\n')}</g>`;
      }

      renderScoreLabels() {
        const { scale, center, style } = this.config;
        const elements = [];
        const fontSize = style.scoreLabelFontSize || 14;
        const fillColor = style.scoreLabelColor || '#ffffff';
        const strokeColor = style.scoreLabelStrokeColor || '#333333';
        const ringStep = (this.outerRadius - center.radius) / scale.rings;
        for (let i = 0; i < scale.rings; i++) {
          const label = scale.min + i;
          const labelRadius = center.radius + ((i + 0.5) * ringStep);
          const y = this.cy - labelRadius;
          elements.push(`<text x="${this.cx}" y="${y}" font-family="${style.fontFamily}" font-size="${fontSize}px" font-weight="bold" text-anchor="middle" dominant-baseline="middle" fill="${fillColor}" stroke="${strokeColor}" stroke-width="3" paint-order="stroke">${label}</text>`);
        }
        return `<g class="score-labels">${elements.join('\n')}</g>`;
      }

      renderSegmentBackgrounds() {
        const { segments, center, startAngle } = this.config;
        const segAngle = segmentAngle(segments.length);
        const elements = [];
        segments.forEach((segment, i) => {
          const sStart = startAngle + i * segAngle;
          const sEnd = sStart + segAngle;
          const bgPath = segmentPath(this.cx, this.cy, center.radius, this.outerRadius, sStart, sEnd);
          elements.push(`<path d="${bgPath}" fill="${segment.color}" opacity="0.3" />`);
        });
        return `<g class="segment-backgrounds">${elements.join('\n')}</g>`;
      }

      renderScoreFills() {
        const { segments, center, scale, startAngle, style } = this.config;
        const segAngle = segmentAngle(segments.length);
        const elements = [];
        segments.forEach((segment, segIndex) => {
          const segStart = startAngle + segIndex * segAngle;
          const segEnd = segStart + segAngle;
          const facetAngleData = facetAngles(segStart, segEnd, segment.facets.length);
          segment.facets.forEach((facet, facetIndex) => {
            if (facet.score === undefined || facet.score === null) return;
            const { startAngle: fStart, endAngle: fEnd } = facetAngleData[facetIndex];
            const scoreRadius = scoreToRadius(facet.score, scale.min, scale.max, center.radius, this.outerRadius);
            const fillPath = segmentPath(this.cx, this.cy, center.radius, scoreRadius, fStart, fEnd);
            elements.push(`<path d="${fillPath}" fill="${segment.color}" opacity="${style.facetOpacity}" />`);
          });
        });
        return `<g class="score-fills">${elements.join('\n')}</g>`;
      }

      renderSegmentDividers() {
        const { segments, center, startAngle, style } = this.config;
        const segAngle = segmentAngle(segments.length);
        const elements = [];
        segments.forEach((_, i) => {
          const angle = startAngle + i * segAngle;
          const inner = polarToCartesian(this.cx, this.cy, center.radius, angle);
          const outer = polarToCartesian(this.cx, this.cy, this.outerRadius, angle);
          elements.push(`<line x1="${inner.x}" y1="${inner.y}" x2="${outer.x}" y2="${outer.y}" stroke="${style.segmentDividerColor}" stroke-width="${style.segmentDividerWidth}" />`);
        });
        return `<g class="segment-dividers">${elements.join('\n')}</g>`;
      }

      renderFacetDividers() {
        const { segments, center, startAngle, style } = this.config;
        const segAngle = segmentAngle(segments.length);
        const elements = [];
        segments.forEach((segment, segIndex) => {
          const segStart = startAngle + segIndex * segAngle;
          const segEnd = segStart + segAngle;
          const facetAngleData = facetAngles(segStart, segEnd, segment.facets.length);
          facetAngleData.forEach((facet, facetIndex) => {
            if (facetIndex === 0) return;
            const inner = polarToCartesian(this.cx, this.cy, center.radius, facet.startAngle);
            const outer = polarToCartesian(this.cx, this.cy, this.outerRadius, facet.startAngle);
            elements.push(`<line x1="${inner.x}" y1="${inner.y}" x2="${outer.x}" y2="${outer.y}" stroke="${style.segmentDividerColor}" stroke-width="1" opacity="0.5" />`);
          });
          if (style.showFacetPoints && style.facetPointStyle !== 'none') {
            facetAngleData.forEach((facetData) => {
              const pointRadius = style.facetPointStyle === 'circle' ? 6 : 3;
              const arcRadius = this.outerRadius - 20;
              const point = polarToCartesian(this.cx, this.cy, arcRadius, facetData.midAngle);
              elements.push(`<circle cx="${point.x}" cy="${point.y}" r="${pointRadius}" fill="white" stroke="${style.segmentDividerColor}" stroke-width="1" />`);
            });
          }
        });
        return `<g class="facet-dividers">${elements.join('\n')}</g>`;
      }

      renderCenterHub() {
        const { center, style } = this.config;
        if (center.visible === false) return '';
        const elements = [];
        const borderWidth = center.borderWidth || 0;
        const borderColor = center.borderColor || '#ffffff';
        if (borderWidth > 0) {
          elements.push(`<circle cx="${this.cx}" cy="${this.cy}" r="${center.radius}" fill="${center.color}" stroke="${borderColor}" stroke-width="${borderWidth}" />`);
        } else {
          elements.push(`<circle cx="${this.cx}" cy="${this.cy}" r="${center.radius}" fill="${center.color}" />`);
        }
        const lines = center.label.split('&').map(s => s.trim());
        const availableWidth = center.radius * 1.6;
        const maxLineLength = Math.max(...lines.map((l, idx) => l.length + (lines.length > 1 && idx === 1 ? 2 : 0)));
        const scaledFontSize = Math.floor(availableWidth / (maxLineLength * 0.6));
        const lineHeight = scaledFontSize * 1.2;
        if (lines.length === 1) {
          const safeLabel = center.label.replace(/&/g, '&amp;');
          elements.push(`<text x="${this.cx}" y="${this.cy}" class="center-label" style="font-size: ${scaledFontSize}px" dominant-baseline="middle">${safeLabel}</text>`);
        } else {
          const startY = this.cy - ((lines.length - 1) * lineHeight) / 2;
          lines.forEach((line, i) => {
            const y = startY + i * lineHeight;
            const text = i === 1 ? `&amp; ${line}` : line;
            elements.push(`<text x="${this.cx}" y="${y}" class="center-label" style="font-size: ${scaledFontSize}px" dominant-baseline="middle">${text}</text>`);
          });
        }
        return `<g class="center-hub">${elements.join('\n')}</g>`;
      }

      renderFacetLabels() {
        const { segments, center, startAngle } = this.config;
        const segAngle = segmentAngle(segments.length);
        const elements = [];
        const labelRadius = this.outerRadius - 20;
        segments.forEach((segment, segIndex) => {
          const segStart = startAngle + segIndex * segAngle;
          const segEnd = segStart + segAngle;
          const segMid = (segStart + segEnd) / 2;
          const facetAngleData = facetAngles(segStart, segEnd, segment.facets.length);
          const normalizedSegMid = ((segMid % 360) + 360) % 360;
          const needsFlip = normalizedSegMid > 90 && normalizedSegMid <= 270;
          const rotationOffset = needsFlip ? 180 : 0;
          const isTopHalf = normalizedSegMid <= 90 || normalizedSegMid > 270;
          const anchor = isTopHalf ? 'end' : 'start';
          segment.facets.forEach((facet, facetIndex) => {
            const { midAngle } = facetAngleData[facetIndex];
            const rotation = midAngle + rotationOffset;
            const pos = polarToCartesian(this.cx, this.cy, labelRadius, midAngle);
            const safeName = facet.name.replace(/&/g, '&amp;');
            elements.push(`<text x="${pos.x}" y="${pos.y}" class="facet-label" text-anchor="${anchor}" dominant-baseline="middle" transform="rotate(${rotation}, ${pos.x}, ${pos.y})">${safeName}</text>`);
          });
        });
        return `<g class="facet-labels">${elements.join('\n')}</g>`;
      }

      renderSegmentLabels() {
        const { segments, startAngle, style } = this.config;
        const segAngle = segmentAngle(segments.length);
        const defs = [];
        const backgrounds = [];
        const dividers = [];
        const texts = [];
        const baseFontSize = style.segmentFontSize || 28;
        const phi = 1.618;
        const arcThickness = (baseFontSize * phi) + baseFontSize;
        const dividerWidth = style.segmentDividerWidth || 4;
        const innerLabelRadius = this.outerRadius + (dividerWidth / 2);
        const outerLabelRadius = innerLabelRadius + arcThickness;
        const textRadius = innerLabelRadius + (arcThickness / 2);
        const arcLength = textRadius * (segAngle - 6) * (Math.PI / 180);
        const maxNameLength = Math.max(...segments.map(s => s.name.length));
        const estTextWidth = (maxNameLength + 1) * baseFontSize * 0.6;
        const scaledFontSize = estTextWidth > arcLength ? Math.floor(baseFontSize * (arcLength / estTextWidth)) : baseFontSize;

        segments.forEach((segment, i) => {
          const segStart = startAngle + i * segAngle;
          const segEnd = segStart + segAngle;
          const midAngle = (segStart + segEnd) / 2;
          const pathId = `segment-path-${i}`;
          const bgPath = segmentPath(this.cx, this.cy, innerLabelRadius, outerLabelRadius, segStart, segEnd);
          backgrounds.push(`<path d="${bgPath}" fill="${segment.color}" />`);
          if (style.showSegmentDividers) {
            const inner = polarToCartesian(this.cx, this.cy, innerLabelRadius, segStart);
            const outer = polarToCartesian(this.cx, this.cy, outerLabelRadius, segStart);
            dividers.push(`<line x1="${inner.x}" y1="${inner.y}" x2="${outer.x}" y2="${outer.y}" stroke="${style.segmentDividerColor}" stroke-width="${style.segmentDividerWidth}" />`);
          }
          const safeName = segment.name.replace(/&/g, '&amp;');
          const normalizedMid = ((midAngle % 360) + 360) % 360;
          const useClockwise = normalizedMid < 15 || normalizedMid > 165;
          if (useClockwise) {
            const start = polarToCartesian(this.cx, this.cy, textRadius, segStart + 3);
            const end = polarToCartesian(this.cx, this.cy, textRadius, segEnd - 3);
            const largeArc = segAngle - 6 > 180 ? 1 : 0;
            defs.push(`<path id="${pathId}" d="M ${start.x} ${start.y} A ${textRadius} ${textRadius} 0 ${largeArc} 1 ${end.x} ${end.y}" fill="none" />`);
          } else {
            const start = polarToCartesian(this.cx, this.cy, textRadius, segEnd - 3);
            const end = polarToCartesian(this.cx, this.cy, textRadius, segStart + 3);
            const largeArc = segAngle - 6 > 180 ? 1 : 0;
            defs.push(`<path id="${pathId}" d="M ${start.x} ${start.y} A ${textRadius} ${textRadius} 0 ${largeArc} 0 ${end.x} ${end.y}" fill="none" />`);
          }
          texts.push(`<text class="segment-label" fill="white" style="font-size: ${scaledFontSize}px"><textPath href="#${pathId}" startOffset="50%" text-anchor="middle">${safeName}</textPath></text>`);
        });

        const ringDivider = style.showSegmentDividers
          ? `<circle cx="${this.cx}" cy="${this.cy}" r="${this.outerRadius}" fill="none" stroke="${style.segmentDividerColor}" stroke-width="${dividerWidth}" />`
          : '';
        return `<defs>${defs.join('\n')}</defs>\n${ringDivider}\n<g class="segment-label-backgrounds">${backgrounds.join('\n')}</g>\n<g class="segment-label-dividers">${dividers.join('\n')}</g>\n<g class="segment-labels">${texts.join('\n')}</g>`;
      }
    }

    // ============================================================
    // Application
    // ============================================================

    let currentSVG = '';

    const exampleConfig = {
      "size": 800,
      "startAngle": -90,
      "center": {
        "label": "Diagram Hub",
        "radius": 100,
        "color": "#475569",
        "borderWidth": 8,
        "borderColor": "#ffffff",
        "fontSize": 14,
        "fontColor": "#ffffff",
        "visible": true
      },
      "scale": {
        "min": 1,
        "max": 5,
        "rings": 5
      },
      "segments": [
        {
          "name": "Segment 1",
          "color": "#3B82F6",
          "facets": [
            {
              "name": "Section 1",
              "score": 3
            }
          ]
        },
        {
          "name": "Segment 2",
          "color": "#8B5CF6",
          "facets": [
            {
              "name": "Section 1",
              "score": 4
            },
            {
              "name": "Section 2",
              "score": 2
            }
          ]
        },
        {
          "name": "Segment 3",
          "color": "#EC4899",
          "facets": [
            {
              "name": "Section 1",
              "score": 3
            },
            {
              "name": "Section 2",
              "score": 2
            },
            {
              "name": "Section 3",
              "score": 4
            }
          ]
        },
        {
          "name": "Segment 4",
          "color": "#F97316",
          "facets": [
            {
              "name": "Section 1",
              "score": 2
            },
            {
              "name": "Section 2",
              "score": 1
            },
            {
              "name": "Section 3",
              "score": 4
            },
            {
              "name": "Section 4",
              "score": 3
            }
          ]
        },
        {
          "name": "Segment 5",
          "color": "#22C55E",
          "facets": [
            {
              "name": "Section 1",
              "score": 5
            },
            {
              "name": "Section 2",
              "score": 3
            },
            {
              "name": "Section 3",
              "score": 4
            },
            {
              "name": "Section 4",
              "score": 2
            },
            {
              "name": "Section 5",
              "score": 3
            }
          ]
        },
        {
          "name": "Segment 6",
          "color": "#06B6D4",
          "facets": [
            {
              "name": "Section 1",
              "score": 3
            },
            {
              "name": "Section 2",
              "score": 4
            },
            {
              "name": "Section 3",
              "score": 2
            },
            {
              "name": "Section 4",
              "score": 5
            },
            {
              "name": "Section 5",
              "score": 1
            },
            {
              "name": "Section 6",
              "score": 4
            }
          ]
        }
      ],
      "style": {
        "fontFamily": "Verdana, sans-serif",
        "segmentFontSize": 28,
        "showSegmentDividers": true,
        "segmentDividerWidth": 8,
        "segmentDividerColor": "#ffffff",
        "facetFontSize": 18,
        "facetFontColor": "#000000",
        "facetOpacity": 0.8,
        "showFacetPoints": false,
        "facetPointStyle": "circle",
        "showRings": true,
        "ringColor": "#fff",
        "ringWidth": 1,
        "ringStyle": "dashed",
        "showScoreLabels": true,
        "scoreLabelFontSize": 10,
        "scoreLabelColor": "#000",
        "scoreLabelStrokeColor": "#33333300"
      }
    };

    document.addEventListener('DOMContentLoaded', function() {
      document.getElementById('config-editor').value = JSON.stringify(exampleConfig, null, 2);
      renderDiagram();
    });

    function isColorDark(color) {
      let hex = color.replace('#', '');
      if (hex.length === 3) hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
      if (hex.length < 6) return false;
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      return luminance < 0.5;
    }

    function renderDiagram() {
      const errorEl = document.getElementById('error');
      const previewEl = document.getElementById('preview');
      try {
        const configText = document.getElementById('config-editor').value;
        const config = JSON.parse(configText);
        const fullConfig = createConfig(config);
        const renderer = new SVGRenderer(fullConfig);
        currentSVG = renderer.render();
        previewEl.innerHTML = currentSVG;
        errorEl.textContent = '';
        const bgColor = config.style?.backgroundColor || '#ffffff';
        previewEl.style.backgroundColor = bgColor;
        previewEl.classList.toggle('dark', isColorDark(bgColor));
      } catch (e) {
        errorEl.textContent = 'Error: ' + e.message;
      }
    }

    function downloadSVG() {
      if (!currentSVG) { alert('Please render a diagram first'); return; }
      const blob = new Blob([currentSVG], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'radial-diagram.svg';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function downloadPNG() {
      if (!currentSVG) { alert('Please render a diagram first'); return; }
      let bgColor = '#ffffff', size = 800;
      try {
        const config = JSON.parse(document.getElementById('config-editor').value);
        bgColor = config.style?.backgroundColor || '#ffffff';
        size = config.size || 800;
      } catch (e) {}
      try {
        const svgEl = document.querySelector('#preview svg');
        if (!svgEl) { alert('No SVG found. Please render a diagram first.'); return; }
        const svgClone = svgEl.cloneNode(true);
        svgClone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(svgClone);
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
        const svgUrl = URL.createObjectURL(svgBlob);
        img.onload = function() {
          try {
            const scale = 2;
            const canvasSize = (size + 140) * scale;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            URL.revokeObjectURL(svgUrl);
            canvas.toBlob(function(blob) {
              if (!blob) { alert('Failed to generate PNG.'); return; }
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'radial-diagram.png';
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            }, 'image/png');
          } catch (err) {
            URL.revokeObjectURL(svgUrl);
            alert('Failed to render PNG: ' + err.message);
          }
        };
        img.onerror = function() {
          URL.revokeObjectURL(svgUrl);
          alert('Failed to load SVG for PNG conversion.');
        };
        img.src = svgUrl;
      } catch (err) {
        alert('Failed to export PNG: ' + err.message);
      }
    }
  </script>
</body>
</html>
